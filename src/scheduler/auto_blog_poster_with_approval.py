"""
Automated Blog Posting Scheduler with Approval Queue
Creates posts in pending_approval status for admin review
This script should be run as a cron job (e.g., daily at midnight)
"""

import os
import sys
import requests
import secrets
import re
from datetime import datetime, timedelta

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from src.models.user import db
from src.models.blog_enhanced import BlogPostEnhanced
from src.models.blog_topic import BlogTopic, BlogSchedule
from flask import Flask

# Initialize Flask app for database access
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = f"sqlite:///{os.path.join(os.path.dirname(os.path.dirname(__file__)), 'database', 'tenantguard.db')}"
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db.init_app(app)

def check_and_generate_post():
    """Check if a new post should be generated and create it for approval"""
    
    with app.app_context():
        # Get schedule configuration
        schedule = BlogSchedule.query.first()
        
        if not schedule or not schedule.auto_posting_enabled:
            print("Auto-posting is disabled. Exiting.")
            return
        
        # Get the most recent published post
        latest_post = BlogPostEnhanced.query.filter_by(status='published').order_by(BlogPostEnhanced.published_at.desc()).first()
        
        # Determine if we should post
        should_post = False
        reason = ""
        days_since_last = 0
        
        if not latest_post:
            should_post = True
            reason = "No posts exist yet"
        else:
            days_since_last = (datetime.utcnow() - latest_post.published_at).days
            if days_since_last >= schedule.max_days_between_posts:
                should_post = True
                reason = f"Last post was {days_since_last} days ago (max: {schedule.max_days_between_posts})"
        
        if not should_post:
            print(f"No post needed. Last post was {days_since_last} days ago.")
            return
        
        print(f"Generating new post for approval. Reason: {reason}")
        
        # Check for pending topics
        pending_topics = BlogTopic.query.filter_by(status='pending').order_by(BlogTopic.priority.desc(), BlogTopic.created_at.asc()).all()
        
        if pending_topics:
            # Use the highest priority pending topic
            topic = pending_topics[0]
            print(f"Using suggested topic: {topic.title}")
            
            # Mark topic as in progress
            topic.status = 'in_progress'
            db.session.commit()
            
            generate_post_from_topic(topic)
        else:
            # No pending topics, generate based on recent trends
            print("No pending topics. Generating post based on recent trends.")
            generate_autonomous_post()


def generate_post_from_topic(topic):
    """Generate a blog post from a suggested topic and submit for approval"""
    
    print(f"Generating post from topic: {topic.title}")
    print(f"Category: {topic.category}")
    print(f"Research links: {topic.research_links}")
    print(f"Research notes: {topic.research_notes}")
    
    # Generate slug
    slug = re.sub(r'[^a-z0-9]+', '-', topic.title.lower()).strip('-')
    
    # Check if slug exists
    existing_post = BlogPostEnhanced.query.filter_by(slug=slug).first()
    if existing_post:
        slug = f"{slug}-{secrets.token_hex(4)}"
    
    # TODO: Integrate with Manus API to generate actual content
    # For now, create a placeholder post
    
    post_content = f"""
# {topic.title}

This post was generated by Manus based on the suggested topic.

**Category:** {topic.category}

**Research Links:**
{topic.research_links if topic.research_links else 'No research links provided'}

**Research Notes:**
{topic.research_notes if topic.research_notes else 'No research notes provided'}

## Content

[Manus will generate comprehensive content here based on research]

This is a placeholder post that demonstrates the approval queue workflow. 
In production, Manus will generate full, high-quality content based on the topic and research materials provided.

## Conclusion

This post is now pending admin approval before publication.
"""
    
    # Create post in pending_approval status
    post = BlogPostEnhanced(
        title=topic.title,
        slug=slug,
        content=post_content,
        excerpt=topic.description or f"Analysis of {topic.title}",
        category=topic.category,
        author="Manus AI",
        status='pending_approval',
        generated_by='manus',
        generation_source='topic_suggestion'
    )
    
    db.session.add(post)
    db.session.flush()
    
    # Submit for approval
    post.submit_for_approval()
    
    # Link topic to post
    topic.blog_post_id = post.id
    topic.status = 'completed'
    topic.completed_at = datetime.utcnow()
    
    db.session.commit()
    
    print(f"Post created successfully (ID: {post.id}) and submitted for approval.")
    print(f"Admins can review and approve at: /admin/approval-queue")


def generate_autonomous_post():
    """Generate a blog post autonomously and submit for approval"""
    
    print("Generating autonomous post based on recent trends...")
    
    with app.app_context():
        # Determine which category needs content
        technical_count = BlogPostEnhanced.query.filter_by(status='published', category='technical').count()
        research_count = BlogPostEnhanced.query.filter_by(status='published', category='market-research').count()
        
        # Balance categories
        category = 'technical' if technical_count <= research_count else 'market-research'
        
        print(f"Selected category: {category}")
        print(f"Technical posts: {technical_count}, Market research posts: {research_count}")
        
        # Generate title based on category
        if category == 'technical':
            title = f"Technical Update: Platform Enhancements - {datetime.now().strftime('%B %Y')}"
            content = """
# Platform Enhancements and Technical Updates

This automated post highlights recent technical improvements to the TenantGuard platform.

## Recent Updates

[Manus will research and document recent platform changes]

## Security Improvements

[Manus will analyze and report on security enhancements]

## Performance Optimizations

[Manus will detail performance improvements]

This post is pending admin approval before publication.
"""
        else:
            title = f"Market Analysis: Tenant Legal Tech Trends - {datetime.now().strftime('%B %Y')}"
            content = """
# Tenant Legal Tech Market Analysis

This automated post provides insights into current trends in the tenant legal tech market.

## Market Overview

[Manus will research and analyze current market conditions]

## Legislative Developments

[Manus will summarize recent tenant protection legislation]

## Competitive Landscape

[Manus will analyze competitor movements and market positioning]

This post is pending admin approval before publication.
"""
        
        # Generate slug
        slug = re.sub(r'[^a-z0-9]+', '-', title.lower()).strip('-')
        
        # Check if slug exists
        existing_post = BlogPostEnhanced.query.filter_by(slug=slug).first()
        if existing_post:
            slug = f"{slug}-{secrets.token_hex(4)}"
        
        # Create post in pending_approval status
        post = BlogPostEnhanced(
            title=title,
            slug=slug,
            content=content,
            excerpt=f"Automated {category} update generated by Manus",
            category=category,
            author="Manus AI",
            status='pending_approval',
            generated_by='manus',
            generation_source='autonomous'
        )
        
        db.session.add(post)
        db.session.flush()
        
        # Submit for approval
        post.submit_for_approval()
        
        db.session.commit()
        
        print(f"Autonomous post created successfully (ID: {post.id}) and submitted for approval.")
        print(f"Admins can review and approve at: /admin/approval-queue")


if __name__ == '__main__':
    print(f"=== Automated Blog Posting Scheduler (With Approval Queue) ===")
    print(f"Run time: {datetime.now().isoformat()}")
    print()
    
    try:
        check_and_generate_post()
        print("\nScheduler completed successfully.")
        print("Generated posts are pending admin approval before publication.")
    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
